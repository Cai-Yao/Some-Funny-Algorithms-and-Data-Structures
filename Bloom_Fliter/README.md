# 布隆过滤器（Bloom Filter）

## 引入

在一些场景下，往往需要判断一个元素是否存在一个集合之中，并且这个集合的元素数量往往很大。

对于判断在不在的问题，在过去我们一般使用hash表来处理，将每一个元素映射到一个bit位，但是对于每一个元素都存放一个位置，可能需要大量的存储空间，所以就希望减少空间的消耗。

使用**布隆过滤器**



## 原理

### 概述

使用一个bit数组和k哈希函数组成，当一个元素插入时，就会使用k个哈希函数进行计算得到k个哈希值，并且在这k个位置的值置为1

插入单词tree：

![image-20220308194714296](https://gitee.com/cwkyaoyao/blog_img/raw/master/img/image-20220308194714296.png)

判断一个元素是否在一个集合中，只需要判断k个哈希值对应的位置是否都为1

### 正确性

很容易可以想到，这个方法会出现假阳性，就是可能插入了几个元素，使得了bit数组有很多的1，此时查询未加入的元素，可能导致了k个哈希值恰好都为1，从而出现了假阳性。（哈希冲突）

- 假设 $bit$ 数组的长度为 $m$ ， $k$ 是哈希函数的个数，插入 $n$ 个元素
- 那么对于位置 $i$ ，其未被设置为 $1$ 的概率为 $1-\frac{1}{m}$ 
- 那么在进行 $k$ 次哈希后，该位置还未被设置为 $1$ 的概率为 $(1-\frac{1}{m})^k$
- 显然在插入了 $n$ 个元素后，该位置还未被设置为 $1$ 的概率为 $(1-\frac{1}{m})^{nk}$
- 那么其被设置为 $1$ 的概率为 $1-(1-\frac{1}{m})^{kn}$
- 那么对于查询某一个元素是否在集合中，需要对 $k$ 个位置进行判断是否为 $1$ ，那么出现假阳性的概率为 $(1-(1-\frac{1}{m})^{kn})^k$
- 上面的式子，通过极限计算近似于 $P = (1-e^{-\frac{kn}{m}})^k$
- 那么为了降低假阳性的概率，就是要使得 $P$ 值尽量小，可以通过求导来计算，得到当 $k = \frac{m}{n}ln2$ 时 $P$ 值最小
- 所以我们就可以通过这个值，进行对 $k$ 和 $m$ 的值的设定


## 应用场景

- 黑名单校验
- 快速去重
- 爬虫URL校验
- leveldb和rocksdb快速判断数据是否存在block中，避免频繁访问磁盘
- 解决了缓存穿透

## 总结

### 优点

- 布隆过滤器可以大量的节省内存空间
- 插入和查询时间复杂度都是常数级别

### 缺点

- 不能支持删除
- 哈希函数选择的好坏可能会导致大量的哈希冲突

## 参考链接

[布隆过滤器(一)](https://hardcore.feishu.cn/docs/doccntUpTrWmCkbfK1cITbpy5qc#)

