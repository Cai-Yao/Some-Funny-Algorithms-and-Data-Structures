# SkipList 跳表

## 相关链接

[Skip lists: a probabilistic alternative to balanced trees | Communications of the ACM](https://dl.acm.org/doi/10.1145/78973.78977)

## 为什么需要跳表

对于普通的有序单链表

![image-20220227231013787](https://gitee.com/cwkyaoyao/blog_img/raw/master/img/image-20220227231013787.png)

如果需要查找元素 $19$ ，那样只能从头开始遍历链表，查找的效率很低，平均时间复杂度为 $O(n)$。

那有没有更快的方法呢？

一种就是使用**平衡树**或者是**类平衡树**

另一种就是**跳表**

跳表是 $William Pugh$ 在 $1990$ 年提出的

## 基本原理

跳表的最基本的原理就是从链表中抽出一些元素，并且在上面增加一层索引节点，如下图就在 $6，9，17，21，26$ 中建立了索引节点

![image-20220227231033566](https://gitee.com/cwkyaoyao/blog_img/raw/master/img/image-20220227231033566.png)

现在再查找元素19，只需要遍历元素 $6,9,17,19$，查询的效率得到了提高

同理，可以在索引上再加一层索引，在面对大量的数据进行查找操作，就大大减少遍历的次数，后面会具体分析复杂度。

### 时间复杂度

假设对于每一层，每两个元素就建立一个索引，那么可以知道在每一层查找的元素最多遍历 $3$ 个元素，一共高度就是 $logn$ ，所以查找的时间复杂度 $O(logn)$ 。对于这种情况实际上就是**在有序链表上进行二分查找**，当然选取 $2,3,...,$个元素建立索引，时间复杂度都是 $O(logn)$

### 空间复杂度

假如原始链表包含 $n$ 个元素，则一级索引元素个数为 $n/2$、二级索引元素个数为 $n/4$、三级索引元素个数为 $n/8$ 以此类推。所以，索引节点的总和是：$n/2 + n/4 + n/8 + … + 8 + 4 + 2 = n-2$，**空间复杂度是 O(n)**。

### 插入操作

比较原始的想法就是，通过查找的方式，找到最下层的插入位置，然后插入新的元素。

但是假如一直往链表中添加数据，但是不更新索引，就可能出现两个索引节点之间数据非常多的情况，极端情况，跳表退化为单链表，从而使得查找效率从 $O(logn)$ 退化为 $O(n)$ 。那这种问题该怎么解决呢？我们需要在插入数据的时候，索引节点也需要相应的增加、或者重建索引，来避免查找效率的退化。那我们该如何去维护这个索引呢？

如果重建索引的代价太大，所以 $William Pugh$ 在论文中使用了随机的方式来构建索引

假如跳表每一层的建立索引概率是 $0.5$，所以，我们可以维护一个这样的索引：**随机选 n/2 个元素做为一级索引、随机选 n/4 个元素做为二级索引、随机选 n/8 个元素做为三级索引，依次类推，一直到最顶层索引**。这里每层索引的元素个数已经确定，且每层索引元素选取的足够随机，所以可以通过索引来提升跳表的查找效率。

![image-20220227231043120](https://gitee.com/cwkyaoyao/blog_img/raw/master/img/image-20220227231043120.png)

像上图一样，每一个节点有着不同的高度，通过随机来设置

那么现在的时间复杂度分析主要是通过概率期望的推到，具体可以看论文中的描述

对于现在的跳表，插入操作，我们首先就是从上到下，对于每一层的索引都需要保存下来要插入元素的前一个节点索引，在最底层找到需要插入的位置，在从下往上构建好索引即可。

![image-20220227231101130](https://gitee.com/cwkyaoyao/blog_img/raw/master/img/image-20220227231101130.png)

**元素插入到单链表的时间复杂度为 O(1)**，索引的高度最多为 $logn$，当插入一个元素 $x$ 时，最坏的情况就是元素 $x$ 需要插入到每层索引中，所以插入数据到各层索引中，最坏时间复杂度是 $O(logn)$。

跳表在插入、删除、查找操作上都比较简单类似，具体细节可以阅读代码

## 基本应用

- 在 $Redis$ 中实现有序集合 $(zset)$
  - 范围区间查找元素，红黑树的效率没有跳表高
- $HBase MemStore$ 内部存储数据就使用的跳表
  - $LSM \ Tree$ 结构的数据库有个特点，写入的数据先写入到内存，内存达到阈值在向往磁盘写，会生成**有序文件**，而跳表恰好就是天然有序的，所以在写磁盘的时候效率很高
- $LevelDB$ 和 $RocksDB$ 的 $MemTable$ 都是用了跳表
- $MySQL$ 的 $Innodb$ 表，为什么不用 $skiplist$，而用 $b+$ 树
  - 对于磁盘文件，$b+$ 树 比 $skiplist$ 好。磁盘查询性能比内存差很多，所以尽量减少查询的次数。
    $b+$ 树每个节点可以存储多个数据，每次查询可以查询一批数据到内存中，而且$b+$ 树的层数低，可以减少访问磁盘的次数。


